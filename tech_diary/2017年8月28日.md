1. python 列表 <code>*</code> 的坑
```python
board = [['_'] * 3 for i in range(3)]
board
Out[46]:
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
In [47]:

board
board[1][2] = 'X'
board
Out[47]:
[['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]
```
这个相当于
```python


board = []
for i in range(3):
    row = ['_'] * 3
    board.append(row)
board
Out[57]:
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
In [58]:

board[1][2] = 'X'
board
Out[58]:
[['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]
```
但是
```python

weird_board = [['_'] * 3]  * 3
weird_board
weird_board = [['_'] * 3]  * 3
weird_board
Out[59]:
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
In [60]:

weird_board[1][2] = 'X'
weird_board
Out[60]:
[['_', '_', 'X'], ['_', '_', 'X'], ['_', '_', 'X']]
```
相当于
```python
row = ['_'] * 3
weird_board = []
for i in range(3):
    weird_board.append(row)
weird_board[1][2] = 'X'
weird_board
Out[62]:
[['_', '_', 'X'], ['_', '_', 'X'], ['_', '_', 'X']]
```
1. python中<code>+=</code>要注意的 首先<code>a += b</code>会调用a实现了的<code>\_\_iadd\_\_</code>方法，
如果没有这个方法才会调用<code>\_\_add\_\_</code>方法。而可变序列一般都实现了<code>\_\_iadd\_\_</code>方法，
而不可变对象根本不支持这个操作。下面展示了<code>*=</code>再不可变序列上的作用。
```python

l = [1,2,3]
In [1]: l=[1,2,3]

In [2]: id(l)
Out[2]: 2396048446664

In [3]: l *= 2

In [4]: l
Out[4]: [1, 2, 3, 1, 2, 3]

In [5]: id(l)
Out[5]: 2396048446664

In [6]: t=(1,2,3)

In [7]: id(t)
Out[7]: 2396048383360

In [8]: t*=2

In [9]: t
Out[9]: (1, 2, 3, 1, 2, 3)

In [10]: id(t)
Out[10]: 2396048501448
```
出现这样的原因就是因为list的l调用了list里的<code>\_\_iadd()\_\_</code>方法，而属于tuple的t由于不支持修改没有
<code>\_\_iadd()\_\_</code>方法而调用了<code>\_\_add()\_\_</code>方法。
1. 面试题选择
```python
In [13]: t = (1, 2, [30, 40])

In [14]: t[2] += [50,60]
```
以上代码的输出是什么？

<ol type='a'>
<li >t 变成 (1, 2, [30, 40, 50, 60])</li>
<li> 因为tuple不支持对它的赋值操作，所以会抛出TypeError异常。</li>
<li>以上两个都不是</li>
<li>a和b都是对的</li>
</ol>
答案是什么？你以为是b，其实是d，a和b都是对的。结果是

```python
In [13]: t = (1, 2, [30, 40])
In [14]: t[2] += [50,60]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-14-fb586dd7f384> in <module>()
----> 1 t[2] += [50,60]
TypeError: 'tuple' object does not support item assignment
In [15]: t
Out[15]: (1, 2, [30, 40, 50, 60])
```
原因是+=不是原子操作，尽量不要再tuple里嵌套可变对象。可以查看字节码来真相了
```python
In [11]: from dis import dis

In [12]: dis('s[a] += b')
  1           0 LOAD_NAME                0 (s)
              2 LOAD_NAME                1 (a)
              4 DUP_TOP_TWO
              6 BINARY_SUBSCR                   # 将s[a]的值压入栈顶TOS（Top of Stack)
              8 LOAD_NAME                2 (b)
             10 INPLACE_ADD                     # 计算TOS += b 这里能完成是因为TOS指向的是一个可变对象。
             12 ROT_THREE
             14 STORE_SUBSCR                    # 这一步失败，因为s是不可变元组
             16 LOAD_CONST               0 (None)
             18 RETURN_VALUE
```
